// SPDX-License-Identifier: LGPL-3.0-or-later
#include <fcntl.h>
#include <gtest/gtest.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <algorithm>
#include <cmath>
#include <fstream>
#include <vector>

#include "DeepSpin.h"
#include "neighbor_list.h"
#include "test_utils.h"

// 1e-10 cannot pass; unclear bug or not
#undef EPSILON
#define EPSILON (std::is_same<VALUETYPE, double>::value ? 1e-7 : 1e-1)

template <class VALUETYPE>
class TestInferDeepSpinDpaPt : public ::testing::Test {
 protected:
  std::vector<VALUETYPE> coord = {12.83, 2.56, 2.18, 12.09, 2.87, 2.74,
                                  00.25, 3.32, 1.68, 3.36,  3.00, 1.81,
                                  3.51,  2.51, 2.60, 4.27,  3.22, 1.56};
  std::vector<VALUETYPE> spin = {0.13, 0.02, 0.03, 0., 0., 0., 0., 0., 0.,
                                 0.14, 0.10, 0.12, 0., 0., 0., 0., 0., 0.};

  std::vector<int> atype = {0, 1, 1, 0, 1, 1};
  std::vector<VALUETYPE> box = {13., 0., 0., 0., 13., 0., 0., 0., 13.};
  // Generated by the following Python code:
  // import numpy as np
  // from deepmd.infer import DeepPot
  // coord = np.array([
  //     12.83, 2.56, 2.18, 12.09, 2.87, 2.74,
  //     00.25, 3.32, 1.68, 3.36,  3.00, 1.81,
  //     3.51,  2.51, 2.60, 4.27,  3.22, 1.56
  // ]).reshape(1, -1)
  // spin = np.array([
  //      0.13, 0.02, 0.03, 0., 0., 0., 0., 0., 0.,
  //      0.14, 0.10, 0.12, 0., 0., 0., 0., 0., 0.
  //      ]).reshape(1, -1)
  // atype = np.array([0, 1, 1, 0, 1, 1])
  // box = np.array([13., 0., 0., 0., 13., 0., 0., 0., 13.]).reshape(1, -1)
  // dp = DeepPot("deeppot_dpa_spin.pth")
  // e, f, v, ae, av, fm, _ = dp.eval(coord, box, atype, atomic=True, spin=spin)
  // np.set_printoptions(precision=16)
  // print(f"{e.ravel()=} {f.ravel()=} {v.ravel()=} {fm.ravel()=}
  // {ae.ravel()=}")

  std::vector<VALUETYPE> expected_e = {-5.835211567762678, -5.071189078159807,
                                       -5.044361601406714, -5.582324154346982,
                                       -5.059906899269188, -5.074135576182056};
  std::vector<VALUETYPE> expected_f = {
      -0.0619881702551019, 0.0646720543680956,  0.2137632336140034,
      0.0378001738771361,  -0.0963276230083563, -0.153191189238485,
      -0.112204927558682,  0.0299145670766558,  -0.0589474826303669,
      0.2278904556868226,  0.0382061907026395,  0.0888060647788163,
      -0.0078898845686436, 0.0019385598635835,  -0.079161612966436,
      -0.0836076471815266, -0.0384037490026167, -0.0112690135575319};
  std::vector<VALUETYPE> expected_fm = {
      -3.077830138662336,
      -1.3135930534661686,
      -0.8332043979367388,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      -0.5452347545527724,
      -0.2051506559632141,
      -0.4908015055951336,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
  };
  std::vector<VALUETYPE> expected_tot_v = {
      -0.02421162406248903,  -0.007399464728803163, 0.012770296772824489,
      -0.005129031187923775, 0.001381624482046452,  0.00660380864594899,
      0.013956096416149198,  0.006788089581579212,  -0.0102462390797404};
  std::vector<VALUETYPE> expected_atom_v = {
      1.56445561e-03,  -2.09940556e-04, -2.38887855e-03, 1.97370249e-03,
      4.43423788e-03,  -1.87644028e-03, 2.28936857e-05,  -1.60139439e-03,
      2.42612568e-03,  -8.18033202e-03, -3.63076402e-03, 3.29578144e-03,
      -3.77806007e-03, -5.67947162e-04, 3.71520105e-03,  3.68597629e-03,
      3.58375798e-03,  -3.53992730e-03, -1.25979731e-02, -5.71674421e-04,
      4.05411698e-03,  9.59636201e-05,  2.98503616e-05,  1.41985921e-03,
      3.86508016e-03,  1.60940945e-03,  -4.82848144e-03, 9.92060149e-03,
      1.31159078e-03,  -1.08861454e-03, -1.33848341e-04, 2.24873882e-03,
      -3.35090985e-03, -2.53510394e-03, -2.99970681e-03, 4.43709623e-03,
      -1.06689446e-02, -2.83469144e-03, 5.46665681e-03,  -1.93195329e-03,
      -1.85479946e-03, 2.29490155e-03,  4.39982122e-03,  1.49850013e-03,
      -1.63963632e-03, -4.24943142e-03, -1.46398507e-03, 3.43123463e-03,
      -1.35483560e-03, -2.90845595e-03, 4.40119696e-03,  4.51742900e-03,
      4.69752322e-03,  -7.10141593e-03};

  int natoms;
  double expected_tot_e;

  deepmd::DeepSpin dp;

  void SetUp() override {
#ifndef BUILD_PYTORCH
    GTEST_SKIP() << "Skip because PyTorch support is not enabled.";
#endif
    dp.init("../../tests/infer/deeppot_dpa_spin.pth");

    natoms = expected_e.size();
    EXPECT_EQ(natoms * 3, expected_f.size());
    EXPECT_EQ(natoms * 3, expected_fm.size());
    EXPECT_EQ(9, expected_tot_v.size());
    EXPECT_EQ(natoms * 9, expected_atom_v.size());
    expected_tot_e = 0.;
    for (int ii = 0; ii < natoms; ++ii) {
      expected_tot_e += expected_e[ii];
    }
  };

  void TearDown() override {};
};

TYPED_TEST_SUITE(TestInferDeepSpinDpaPt, ValueTypes);

TYPED_TEST(TestInferDeepSpinDpaPt, cpu_build_nlist) {
  using VALUETYPE = TypeParam;
  const std::vector<VALUETYPE>& coord = this->coord;
  const std::vector<VALUETYPE>& spin = this->spin;
  std::vector<int>& atype = this->atype;
  std::vector<VALUETYPE>& box = this->box;
  std::vector<VALUETYPE>& expected_e = this->expected_e;
  std::vector<VALUETYPE>& expected_f = this->expected_f;
  std::vector<VALUETYPE>& expected_fm = this->expected_fm;
  std::vector<VALUETYPE>& expected_tot_v = this->expected_tot_v;
  int& natoms = this->natoms;
  double& expected_tot_e = this->expected_tot_e;
  deepmd::DeepSpin& dp = this->dp;
  double ener;
  std::vector<VALUETYPE> force, force_mag, virial;
  dp.compute(ener, force, force_mag, virial, coord, spin, atype, box);

  EXPECT_EQ(force.size(), natoms * 3);
  EXPECT_EQ(force_mag.size(), natoms * 3);
  EXPECT_LT(fabs(ener - expected_tot_e), EPSILON);
  for (int ii = 0; ii < natoms * 3; ++ii) {
    EXPECT_LT(fabs(force[ii] - expected_f[ii]), EPSILON);
    EXPECT_LT(fabs(force_mag[ii] - expected_fm[ii]), EPSILON);
  }
  if (virial.empty()) {
    return;
  }
  EXPECT_EQ(virial.size(), 9);
  for (int ii = 0; ii < 3 * 3; ++ii) {
    EXPECT_LT(fabs(virial[ii] - expected_tot_v[ii]), EPSILON);
  }
}

TYPED_TEST(TestInferDeepSpinDpaPt, cpu_build_nlist_atomic) {
  using VALUETYPE = TypeParam;
  const std::vector<VALUETYPE>& coord = this->coord;
  const std::vector<VALUETYPE>& spin = this->spin;
  std::vector<int>& atype = this->atype;
  std::vector<VALUETYPE>& box = this->box;
  std::vector<VALUETYPE>& expected_e = this->expected_e;
  std::vector<VALUETYPE>& expected_f = this->expected_f;
  std::vector<VALUETYPE>& expected_fm = this->expected_fm;
  std::vector<VALUETYPE>& expected_tot_v = this->expected_tot_v;
  std::vector<VALUETYPE>& expected_atom_v = this->expected_atom_v;
  int& natoms = this->natoms;
  double& expected_tot_e = this->expected_tot_e;
  deepmd::DeepSpin& dp = this->dp;
  double ener;
  std::vector<VALUETYPE> force, force_mag, virial, atom_ener, atom_vir;
  dp.compute(ener, force, force_mag, virial, atom_ener, atom_vir, coord, spin,
             atype, box);

  EXPECT_EQ(force.size(), natoms * 3);
  EXPECT_EQ(force_mag.size(), natoms * 3);
  EXPECT_EQ(atom_ener.size(), natoms);

  EXPECT_LT(fabs(ener - expected_tot_e), EPSILON);
  for (int ii = 0; ii < natoms * 3; ++ii) {
    EXPECT_LT(fabs(force[ii] - expected_f[ii]), EPSILON);
    EXPECT_LT(fabs(force_mag[ii] - expected_fm[ii]), EPSILON);
  }
  if (!virial.empty()) {
    EXPECT_EQ(virial.size(), 9);
    for (int ii = 0; ii < 3 * 3; ++ii) {
      EXPECT_LT(fabs(virial[ii] - expected_tot_v[ii]), EPSILON);
    }
  }
  for (int ii = 0; ii < natoms; ++ii) {
    EXPECT_LT(fabs(atom_ener[ii] - expected_e[ii]), EPSILON);
  }
  if (atom_vir.empty()) {
    return;
  }
  EXPECT_EQ(atom_vir.size(), natoms * 9);
  for (int ii = 0; ii < natoms * 9; ++ii) {
    EXPECT_LT(fabs(atom_vir[ii] - expected_atom_v[ii]), EPSILON);
  }
}

template <class VALUETYPE>
class TestInferDeepSpinDpaPtNopbc : public ::testing::Test {
 protected:
  std::vector<VALUETYPE> coord = {12.83, 2.56, 2.18, 12.09, 2.87, 2.74,
                                  00.25, 3.32, 1.68, 3.36,  3.00, 1.81,
                                  3.51,  2.51, 2.60, 4.27,  3.22, 1.56};
  std::vector<VALUETYPE> spin = {0.13, 0.02, 0.03, 0., 0., 0., 0., 0., 0.,
                                 0.14, 0.10, 0.12, 0., 0., 0., 0., 0., 0.};
  std::vector<int> atype = {0, 1, 1, 0, 1, 1};
  std::vector<VALUETYPE> box = {};
  // Generated by the following Python code:
  // import numpy as np
  // from deepmd.infer import DeepPot
  // coord = np.array([
  //     12.83, 2.56, 2.18, 12.09, 2.87, 2.74,
  //     00.25, 3.32, 1.68, 3.36,  3.00, 1.81,
  //     3.51,  2.51, 2.60, 4.27,  3.22, 1.56
  // ]).reshape(1, -1)
  // spin = np.array([
  //      0.13, 0.02, 0.03, 0., 0., 0., 0., 0., 0.,
  //      0.14, 0.10, 0.12, 0., 0., 0., 0., 0., 0.
  //      ]).reshape(1, -1)
  // atype = np.array([0, 1, 1, 0, 1, 1])
  // box = None
  // dp = DeepPot("deeppot_dpa_spin.pth")
  // e, f, v, ae, av, fm, _ = dp.eval(coord, box, atype, atomic=True,
  // spin=spin)
  // np.set_printoptions(precision=16)
  // print(f"{e.ravel()=} {f.ravel()=} {v.ravel()=} {fm.ravel()=}
  // {ae.ravel()=}")

  std::vector<VALUETYPE> expected_e = {-5.921669893870772, -5.167669379175869,
                                       -5.205933794558385, -5.58688965168251,
                                       -5.080322972018686, -5.08213772482076};
  std::vector<VALUETYPE> expected_f = {
      -0.2929142244191496, 0.0801070990501461,  0.1482161785147047,
      0.2929142244191509,  -0.080107099050146,  -0.1482161785147047,
      -0.2094984819251434, 0.024159411895004,   -0.0215199116994508,
      0.3068843038300326,  -0.0016205303448664, 0.1508093841389744,
      -0.0122719879278721, 0.0186341247897136,  -0.1137104245023706,
      -0.0851138339770167, -0.0411730063398516, -0.0155790479371534};
  std::vector<VALUETYPE> expected_fm = {-1.5298530476859904,
                                        0.00713150245469,
                                        0.0650492472558721,
                                        0.0,
                                        0.0,
                                        0.0,
                                        0.0,
                                        0.0,
                                        0.0,
                                        -0.6212052813442372,
                                        -0.2290265978320397,
                                        -0.5101405083352208,
                                        0.0,
                                        0.0,
                                        0.0,
                                        0.0,
                                        0.0,
                                        0.0};
  std::vector<VALUETYPE> expected_tot_v = {
      -0.006855934251658762, -0.00491299773599024,  0.001790727101442579,
      -0.004700307257262127, -0.001921876254115465, 0.00522933533951051,
      0.002220184013052337,  0.005305572188769711,  -0.0015617293208553679};
  std::vector<VALUETYPE> expected_atom_v = {
      0.00223849,  -0.00093775, -0.00169399, -0.00058709, 0.00024594,
      0.00044429,  -0.00108942, 0.00045638,  0.00082442,  0.00331061,
      -0.00138688, -0.00250533, -0.00159569, 0.00066847,  0.00120755,
      -0.00286535, 0.00120035,  0.00216838,  -0.00726106, 0.00110669,
      -0.0011729,  0.00151598,  -0.00037897, 0.0004289,   -0.00116555,
      0.00041409,  -0.00051682, 0.00734061,  0.00124985,  -0.00139847,
      0.00025622,  0.00238308,  -0.00372649, -0.00155401, -0.00312998,
      0.00476667,  -0.00909511, -0.00319323, 0.00524226,  -0.00252116,
      -0.00193343, 0.00250048,  0.00436096,  0.00167675,  -0.00186338,
      -0.00338948, -0.00175168, 0.00331916,  -0.00176855, -0.00290696,
      0.0043746,   0.00453355,  0.00468798,  -0.00694099};

  int natoms;
  double expected_tot_e;

  deepmd::DeepSpin dp;

  void SetUp() override {
#ifndef BUILD_PYTORCH
    GTEST_SKIP() << "Skip because PyTorch support is not enabled.";
#endif
    dp.init("../../tests/infer/deeppot_dpa_spin.pth");

    natoms = expected_e.size();
    EXPECT_EQ(natoms * 3, expected_f.size());
    EXPECT_EQ(natoms * 3, expected_fm.size());
    EXPECT_EQ(9, expected_tot_v.size());
    EXPECT_EQ(natoms * 9, expected_atom_v.size());
    expected_tot_e = 0.;
    for (int ii = 0; ii < natoms; ++ii) {
      expected_tot_e += expected_e[ii];
    }
  };

  void TearDown() override {};
};

TYPED_TEST_SUITE(TestInferDeepSpinDpaPtNopbc, ValueTypes);

TYPED_TEST(TestInferDeepSpinDpaPtNopbc, cpu_build_nlist) {
  using VALUETYPE = TypeParam;
  const std::vector<VALUETYPE>& coord = this->coord;
  const std::vector<VALUETYPE>& spin = this->spin;
  std::vector<int>& atype = this->atype;
  std::vector<VALUETYPE>& box = this->box;
  std::vector<VALUETYPE>& expected_e = this->expected_e;
  std::vector<VALUETYPE>& expected_f = this->expected_f;
  std::vector<VALUETYPE>& expected_fm = this->expected_fm;
  std::vector<VALUETYPE>& expected_tot_v = this->expected_tot_v;
  int& natoms = this->natoms;
  double& expected_tot_e = this->expected_tot_e;
  deepmd::DeepSpin& dp = this->dp;
  double ener;
  std::vector<VALUETYPE> force, force_mag, virial;
  dp.compute(ener, force, force_mag, virial, coord, spin, atype, box);

  EXPECT_EQ(force.size(), natoms * 3);
  EXPECT_EQ(force_mag.size(), natoms * 3);
  EXPECT_LT(fabs(ener - expected_tot_e), EPSILON);
  for (int ii = 0; ii < natoms * 3; ++ii) {
    EXPECT_LT(fabs(force[ii] - expected_f[ii]), EPSILON);
    EXPECT_LT(fabs(force_mag[ii] - expected_fm[ii]), EPSILON);
  }
  if (virial.empty()) {
    return;
  }
  EXPECT_EQ(virial.size(), 9);
  for (int ii = 0; ii < 3 * 3; ++ii) {
    EXPECT_LT(fabs(virial[ii] - expected_tot_v[ii]), EPSILON);
  }
}

TYPED_TEST(TestInferDeepSpinDpaPtNopbc, cpu_build_nlist_atomic) {
  using VALUETYPE = TypeParam;
  const std::vector<VALUETYPE>& coord = this->coord;
  const std::vector<VALUETYPE>& spin = this->spin;
  std::vector<int>& atype = this->atype;
  std::vector<VALUETYPE>& box = this->box;
  std::vector<VALUETYPE>& expected_e = this->expected_e;
  std::vector<VALUETYPE>& expected_f = this->expected_f;
  std::vector<VALUETYPE>& expected_fm = this->expected_fm;
  std::vector<VALUETYPE>& expected_tot_v = this->expected_tot_v;
  std::vector<VALUETYPE>& expected_atom_v = this->expected_atom_v;
  int& natoms = this->natoms;
  double& expected_tot_e = this->expected_tot_e;
  deepmd::DeepSpin& dp = this->dp;
  double ener;
  std::vector<VALUETYPE> force, force_mag, virial, atom_ener, atom_vir;
  dp.compute(ener, force, force_mag, virial, atom_ener, atom_vir, coord, spin,
             atype, box);

  EXPECT_EQ(force.size(), natoms * 3);
  EXPECT_EQ(force_mag.size(), natoms * 3);
  EXPECT_EQ(atom_ener.size(), natoms);

  EXPECT_LT(fabs(ener - expected_tot_e), EPSILON);
  for (int ii = 0; ii < natoms * 3; ++ii) {
    EXPECT_LT(fabs(force[ii] - expected_f[ii]), EPSILON);
    EXPECT_LT(fabs(force_mag[ii] - expected_fm[ii]), EPSILON);
  }
  if (!virial.empty()) {
    EXPECT_EQ(virial.size(), 9);
    for (int ii = 0; ii < 3 * 3; ++ii) {
      EXPECT_LT(fabs(virial[ii] - expected_tot_v[ii]), EPSILON);
    }
  }
  for (int ii = 0; ii < natoms; ++ii) {
    EXPECT_LT(fabs(atom_ener[ii] - expected_e[ii]), EPSILON);
  }
  if (atom_vir.empty()) {
    return;
  }
  EXPECT_EQ(atom_vir.size(), natoms * 9);
  for (int ii = 0; ii < natoms * 9; ++ii) {
    EXPECT_LT(fabs(atom_vir[ii] - expected_atom_v[ii]), EPSILON);
  }
}

TYPED_TEST(TestInferDeepSpinDpaPtNopbc, cpu_lmp_nlist) {
  using VALUETYPE = TypeParam;
  const std::vector<VALUETYPE>& coord = this->coord;
  const std::vector<VALUETYPE>& spin = this->spin;
  std::vector<int>& atype = this->atype;
  std::vector<VALUETYPE>& box = this->box;
  std::vector<VALUETYPE>& expected_e = this->expected_e;
  std::vector<VALUETYPE>& expected_f = this->expected_f;
  std::vector<VALUETYPE>& expected_fm = this->expected_fm;
  std::vector<VALUETYPE>& expected_tot_v = this->expected_tot_v;
  int& natoms = this->natoms;
  double& expected_tot_e = this->expected_tot_e;
  deepmd::DeepSpin& dp = this->dp;
  double ener;
  std::vector<VALUETYPE> force, force_mag, virial;

  std::vector<std::vector<int> > nlist_data = {
      {1, 2, 3, 4, 5}, {0, 2, 3, 4, 5}, {0, 1, 3, 4, 5},
      {0, 1, 2, 4, 5}, {0, 1, 2, 3, 5}, {0, 1, 2, 3, 4}};
  std::vector<int> ilist(natoms), numneigh(natoms);
  std::vector<int*> firstneigh(natoms);
  deepmd::InputNlist inlist(natoms, &ilist[0], &numneigh[0], &firstneigh[0]);
  convert_nlist(inlist, nlist_data);
  dp.compute(ener, force, force_mag, virial, coord, spin, atype, box, 0, inlist,
             0);

  EXPECT_EQ(force.size(), natoms * 3);
  EXPECT_EQ(force_mag.size(), natoms * 3);
  EXPECT_LT(fabs(ener - expected_tot_e), EPSILON);
  for (int ii = 0; ii < natoms * 3; ++ii) {
    EXPECT_LT(fabs(force[ii] - expected_f[ii]), EPSILON);
    EXPECT_LT(fabs(force_mag[ii] - expected_fm[ii]), EPSILON);
  }
  if (virial.empty()) {
    return;
  }
  EXPECT_EQ(virial.size(), 9);
  for (int ii = 0; ii < 3 * 3; ++ii) {
    EXPECT_LT(fabs(virial[ii] - expected_tot_v[ii]), EPSILON);
  }
}

TYPED_TEST(TestInferDeepSpinDpaPtNopbc, cpu_lmp_nlist_atomic) {
  using VALUETYPE = TypeParam;
  const std::vector<VALUETYPE>& coord = this->coord;
  const std::vector<VALUETYPE>& spin = this->spin;
  std::vector<int>& atype = this->atype;
  std::vector<VALUETYPE>& box = this->box;
  std::vector<VALUETYPE>& expected_e = this->expected_e;
  std::vector<VALUETYPE>& expected_f = this->expected_f;
  std::vector<VALUETYPE>& expected_fm = this->expected_fm;
  std::vector<VALUETYPE>& expected_tot_v = this->expected_tot_v;
  std::vector<VALUETYPE>& expected_atom_v = this->expected_atom_v;
  int& natoms = this->natoms;
  double& expected_tot_e = this->expected_tot_e;
  deepmd::DeepSpin& dp = this->dp;
  double ener;
  std::vector<VALUETYPE> force, force_mag, virial, atom_ener, atom_vir;

  std::vector<std::vector<int> > nlist_data = {
      {1, 2, 3, 4, 5}, {0, 2, 3, 4, 5}, {0, 1, 3, 4, 5},
      {0, 1, 2, 4, 5}, {0, 1, 2, 3, 5}, {0, 1, 2, 3, 4}};
  std::vector<int> ilist(natoms), numneigh(natoms);
  std::vector<int*> firstneigh(natoms);
  deepmd::InputNlist inlist(natoms, &ilist[0], &numneigh[0], &firstneigh[0]);
  convert_nlist(inlist, nlist_data);
  dp.compute(ener, force, force_mag, virial, atom_ener, atom_vir, coord, spin,
             atype, box, 0, inlist, 0);

  EXPECT_EQ(force.size(), natoms * 3);
  EXPECT_EQ(force_mag.size(), natoms * 3);
  EXPECT_EQ(atom_ener.size(), natoms);

  EXPECT_LT(fabs(ener - expected_tot_e), EPSILON);
  for (int ii = 0; ii < natoms * 3; ++ii) {
    EXPECT_LT(fabs(force[ii] - expected_f[ii]), EPSILON);
    EXPECT_LT(fabs(force_mag[ii] - expected_fm[ii]), EPSILON);
  }
  if (!virial.empty()) {
    EXPECT_EQ(virial.size(), 9);
    for (int ii = 0; ii < 3 * 3; ++ii) {
      EXPECT_LT(fabs(virial[ii] - expected_tot_v[ii]), EPSILON);
    }
  }
  for (int ii = 0; ii < natoms; ++ii) {
    EXPECT_LT(fabs(atom_ener[ii] - expected_e[ii]), EPSILON);
  }
  if (atom_vir.empty()) {
    return;
  }
  EXPECT_EQ(atom_vir.size(), natoms * 9);
  for (int ii = 0; ii < natoms * 9; ++ii) {
    EXPECT_LT(fabs(atom_vir[ii] - expected_atom_v[ii]), EPSILON);
  }
}
